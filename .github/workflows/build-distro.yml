name: Build Distro

on:
  workflow_call:
    inputs:
      build_all:
        description: "Build all machines and perform all tasks"
        type: boolean
        required: true
      target_to_build:
        description: "Select the machine to build"
        type: string
        required: true
      distro_codename:
        description: "Distribution codename"
        type: string
        required: true
    outputs:
      release_date:
        description: "Release date timestamp"
        value: ${{ jobs.determine_build_matrix.outputs.release_date }}
      packages_path:
        description: "Path to packages directory"
        value: ${{ jobs.determine_build_matrix.outputs.packages_path }}
      releases_path:
        description: "Path to releases directory"
        value: ${{ jobs.determine_build_matrix.outputs.releases_path }}
      staging_base_path:
        description: "Base path for staging"
        value: ${{ jobs.determine_build_matrix.outputs.staging_base_path }}
  workflow_dispatch:
    inputs:
      build_all:
        description: "Build all machines and perform all tasks"
        type: boolean
        default: false
      target_to_build:
        description: "Select the machine to build"
        type: choice
        required: true
        options:
          - imx8mp-evk
          - imx91-frdm
          - imx93-frdm
          - imx93-evk
          - qemuarm64
          - qemux86-64
          - reterminal
          - reterminal-dm
          - jetson-orin-nano-devkit-nvme
          - raspberrypi4
          - raspberrypi5
      distro_codename:
        description: "Distribution codename"
        type: string
        default: "latest/apollo/edge"

jobs:
  determine_build_matrix:
    runs-on: avocado-build
    env:
      DISTRO_VERSION: "0.1.0"
      DISTRO_CODENAME: ${{ inputs.distro_codename || github.event.inputs.distro_codename }}
      AVOCADO_REPO_BASE: "https://repo.avocadolinux.org"
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      release_date: ${{ steps.set-paths.outputs.release_date }}
      staging_base_path: ${{ steps.set-paths.outputs.staging_base_path }}
      packages_path: ${{ steps.set-paths.outputs.packages_path }}
      releases_path: ${{ steps.set-paths.outputs.releases_path }}
      distro_codename: ${{ steps.set-paths.outputs.distro_codename }}
    steps:
      - name: Set build paths
        id: set-paths
        run: |
          # Generate timestamp for this build
          RELEASE_DATE=$(date -u '+%Y-%m-%d-%H%M%S')
          REPO_PATH="/home/runner/_repo"
          DISTRO_CODENAME="${{ env.DISTRO_CODENAME }}"

          # New directory structure with proper scoping
          STAGING_BASE_PATH="${REPO_PATH}/staging/${RELEASE_DATE}"
          PACKAGES_PATH="${REPO_PATH}/packages/${DISTRO_CODENAME}"
          RELEASES_PATH="${REPO_PATH}/releases/${DISTRO_CODENAME}/${RELEASE_DATE}"

          echo "release_date=$RELEASE_DATE" >> $GITHUB_OUTPUT
          echo "staging_base_path=$STAGING_BASE_PATH" >> $GITHUB_OUTPUT
          echo "packages_path=$PACKAGES_PATH" >> $GITHUB_OUTPUT
          echo "releases_path=$RELEASES_PATH" >> $GITHUB_OUTPUT
          echo "distro_codename=$DISTRO_CODENAME" >> $GITHUB_OUTPUT

          echo "Generated release date: $RELEASE_DATE"
          echo "Staging base path: $STAGING_BASE_PATH"
          echo "Packages path: $PACKAGES_PATH"
          echo "Releases path: $RELEASES_PATH"

      - name: Determine build parameters
        id: set-matrix
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const allMachinesList = [
              "imx8mp-evk", "imx91-frdm", "imx93-frdm", "qemuarm64", "qemux86-64",
              "reterminal", "reterminal-dm", "imx93-evk", "jetson-orin-nano-devkit-nvme",
              "raspberrypi4", "raspberrypi5"
            ];

            let selectedMachines = [];

            // Handle both workflow_call and workflow_dispatch inputs
            const buildAll = ${{ inputs.build_all || github.event.inputs.build_all == 'true' }};
            const targetToBuild = "${{ inputs.target_to_build || github.event.inputs.target_to_build }}";

            if (buildAll) {
              selectedMachines = allMachinesList;
              core.info('Build all selected: Building all machines.');
            } else {
              core.info(`Target to build: ${targetToBuild}`);

              if (allMachinesList.includes(targetToBuild)) {
                selectedMachines = [targetToBuild];
                core.info(`Selected machine: ${targetToBuild}`);
              } else {
                core.warning(`Unknown target selected: ${targetToBuild}. No machine will be built.`);
              }
            }
            core.setOutput('matrix', JSON.stringify(selectedMachines));

  build:
    needs: determine_build_matrix
    if: needs.determine_build_matrix.outputs.matrix != '[]'
    runs-on: avocado-build
    strategy:
      fail-fast: false
      matrix:
        machine: ${{ fromJSON(needs.determine_build_matrix.outputs.matrix) }}
        build_config:
          - target: avocado-distro
            sdk_machine: x86_64
          - target: avocado-sdk
            sdk_machine: x86_64
          - target: avocado-sdk
            sdk_machine: aarch64
    env:
      STAGING_BASE_PATH: ${{ needs.determine_build_matrix.outputs.staging_base_path }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Create staging directory for this build
        run: |
          echo "=== Debug: Directory permissions and structure ==="
          echo "Current user: $(whoami)"
          echo "Current working directory: $(pwd)"
          echo "Home directory: $HOME"

          echo "=== Checking /home/runner directory ==="
          ls -la /home/runner/ || echo "Cannot list /home/runner/"

          echo "=== Checking if /home/runner/_repo exists ==="
          if [ -d "/home/runner/_repo" ]; then
            echo "/home/runner/_repo exists"
            ls -la /home/runner/_repo/
            echo "Permissions on /home/runner/_repo:"
            stat /home/runner/_repo/
          else
            echo "/home/runner/_repo does not exist"
            echo "Attempting to create /home/runner/_repo"
            mkdir -p /home/runner/_repo || echo "Failed to create /home/runner/_repo"
          fi

          echo "=== Staging path calculation ==="
          if [ "${{ matrix.build_config.target }}" = "avocado-distro" ]; then
            STAGING_PATH="${{ env.STAGING_BASE_PATH }}/avocado-distro/${{ matrix.machine }}"
          else
            STAGING_PATH="${{ env.STAGING_BASE_PATH }}/avocado-sdk/${{ matrix.build_config.sdk_machine }}/${{ matrix.machine }}"
          fi

          echo "STAGING_BASE_PATH: ${{ env.STAGING_BASE_PATH }}"
          echo "STAGING_PATH: $STAGING_PATH"

          echo "=== Attempting to create staging directory ==="
          mkdir -p "$STAGING_PATH" || {
            echo "Failed to create staging directory"
            echo "Checking parent directories:"
            echo "Checking $(dirname "$STAGING_PATH"):"
            ls -la "$(dirname "$STAGING_PATH")" 2>/dev/null || echo "Parent directory does not exist"
            echo "Checking $(dirname "$(dirname "$STAGING_PATH")"):"
            ls -la "$(dirname "$(dirname "$STAGING_PATH")")" 2>/dev/null || echo "Grandparent directory does not exist"
            exit 1
          }

          echo "Successfully created staging directory"
          echo "STAGING_PATH=$STAGING_PATH" >> $GITHUB_ENV

      - name: Build ${{ matrix.build_config.target }} for ${{ matrix.machine }}
        env:
          AVOCADO_REPO_BASE: "https://repo.avocadolinux.org"
          BB_GIT_SHALLOW: "1"
          PARALLEL_MAKE: "-j16"
          SDKMACHINE: ${{ matrix.build_config.sdk_machine }}
          DISTRO_CODENAME: ${{ needs.determine_build_matrix.outputs.distro_codename }}
          # PR Server configuration - connects all workers to a shared PR server
          # Set PRSERV_HOST and PRSERV_PORT as repository secrets
          PRSERV_HOST: "${{ secrets.PRSERV_HOST }}:${{ secrets.PRSERV_PORT }}"
          # Hash Equivalence Server configuration - connects all workers to a shared hash server
          # Set BB_HASHSERVE_HOST as repository secret
          BB_HASHSERVE: "auto"
        run: |
          echo "TARGET: ${{ matrix.build_config.target }}"
          echo "SDKMACHINE: ${{ matrix.build_config.sdk_machine }}"
          echo "DISTRO_CODENAME: ${{ needs.determine_build_matrix.outputs.distro_codename }}"

          source ./distro/scripts/init-build distro/kas/machine/${{ matrix.machine }}.yml
          source .envrc
          kas build "$KAS_YML" --target ${{ matrix.build_config.target }}

      - name: Stage target repos for ${{ matrix.machine }}
        run: |
          echo "Staging repos for ${{ matrix.machine }} to ${{ env.STAGING_PATH }}"
          ls ./build-${{ matrix.machine }}/build/tmp/deploy/rpm
          ./repo/stage-rpms.sh ./build-${{ matrix.machine }}/build/tmp/deploy/rpm ${{ env.STAGING_PATH }} ${{ needs.determine_build_matrix.outputs.distro_codename }}

      - name: Generate target fragment for ${{ matrix.machine }}
        if: matrix.build_config.target == 'avocado-distro'
        run: |
          echo "Generating target fragment for ${{ matrix.machine }}"

          # Create fragments directory in staging base path
          FRAGMENTS_DIR="${{ env.STAGING_BASE_PATH }}/fragments"
          mkdir -p "$FRAGMENTS_DIR"

          # Generate the target fragment using the repo map
          ./repo/generate-target-fragment.sh \
            ./build-${{ matrix.machine }}/build/tmp/deploy/rpm \
            ${{ matrix.machine }} \
            "$FRAGMENTS_DIR" \
            ${{ needs.determine_build_matrix.outputs.distro_codename }}

          echo "Target fragment generated for ${{ matrix.machine }}"

  validate_staging_checksums:
    needs:
      - determine_build_matrix
      - build
    if: needs.build.result == 'success'
    runs-on: avocado-build
    env:
      STAGING_BASE_PATH: ${{ needs.determine_build_matrix.outputs.staging_base_path }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Validate staging directory checksums
        run: |
          echo "=== Validating RPM checksums in staging directory ==="
          echo "Staging path: ${{ env.STAGING_BASE_PATH }}"

          # Run the checksum validation script
          if ./scripts/check-staging-checksums.sh --quiet "${{ env.STAGING_BASE_PATH }}"; then
            echo "✅ Checksum validation passed - all duplicate packages have matching checksums"
          else
            echo "❌ Checksum validation failed - found packages with mismatched checksums"
            echo "Re-running with verbose output for debugging:"
            ./scripts/check-staging-checksums.sh --verbose "${{ env.STAGING_BASE_PATH }}"
            exit 1
          fi

  aggregate_packages:
    needs:
      - determine_build_matrix
      - build
      - validate_staging_checksums
    if: needs.validate_staging_checksums.result == 'success'
    runs-on: avocado-build
    env:
      STAGING_BASE_PATH: ${{ needs.determine_build_matrix.outputs.staging_base_path }}
      PACKAGES_PATH: ${{ needs.determine_build_matrix.outputs.packages_path }}
      RELEASES_PATH: ${{ needs.determine_build_matrix.outputs.releases_path }}
      DISTRO_CODENAME: ${{ needs.determine_build_matrix.outputs.distro_codename }}
      AVOCADO_REPO_BASE: "https://repo.avocadolinux.org"
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Create packages directory
        run: mkdir -p ${{ env.PACKAGES_PATH }}

      - name: Aggregate packages from staging to packages directory
        run: |
          echo "Aggregating packages from staging to packages directory"
          echo "From: ${{ env.STAGING_BASE_PATH }}"
          echo "To: ${{ env.PACKAGES_PATH }}"

          # Aggregate avocado-distro packages
          DISTRO_CODENAME="${{ env.STAGING_BASE_PATH }}/avocado-distro"
          if [ -d "$DISTRO_CODENAME" ]; then
            echo "Aggregating avocado-distro packages"
            # Iterate through each machine directory
            for machine_dir in "$DISTRO_CODENAME"/*; do
              if [ -d "$machine_dir" ]; then
                machine_name=$(basename "$machine_dir")
                echo "Processing machine: $machine_name"
                # Copy contents from the distro-specific subdirectory to avoid double nesting
                DISTRO_SOURCE="$machine_dir/${{ env.DISTRO_CODENAME }}"
                if [ -d "$DISTRO_SOURCE" ]; then
                  rsync -av "$DISTRO_SOURCE/" "${{ env.PACKAGES_PATH }}/"
                else
                  echo "Warning: Expected distro path $DISTRO_SOURCE not found"
                fi
              fi
            done
          fi

          # Aggregate avocado-sdk packages for both architectures
          for sdk_arch in x86_64 aarch64; do
            SDK_ARCH_PATH="${{ env.STAGING_BASE_PATH }}/avocado-sdk/$sdk_arch"
            if [ -d "$SDK_ARCH_PATH" ]; then
              echo "Aggregating avocado-sdk packages for $sdk_arch"
              # Iterate through each machine directory
              for machine_dir in "$SDK_ARCH_PATH"/*; do
                if [ -d "$machine_dir" ]; then
                  machine_name=$(basename "$machine_dir")
                  echo "Processing machine: $machine_name"
                  # Copy contents from the distro-specific subdirectory to avoid double nesting
                  DISTRO_SOURCE="$machine_dir/${{ env.DISTRO_CODENAME }}"
                  if [ -d "$DISTRO_SOURCE" ]; then
                    rsync -av "$DISTRO_SOURCE/" "${{ env.PACKAGES_PATH }}/"
                  else
                    echo "Warning: Expected distro path $DISTRO_SOURCE not found"
                  fi
                fi
              done
            fi
          done

          echo "Package aggregation complete"

      - name: Generate base repository metadata (excluding extensions)
        run: |
          echo "Generating base repository metadata (excluding extensions)"
          echo "Reading packages from: ${{ env.PACKAGES_PATH }}"
          echo "Writing metadata to: ${{ env.RELEASES_PATH }}"
          echo "Metadata will use relative paths to packages"
          ./repo/update-metadata-distro.sh "${{ env.PACKAGES_PATH }}" "" "${{ env.RELEASES_PATH }}"

      - name: Generate targets.json file
        run: |
          echo "Generating targets.json file"
          echo "Aggregating target fragments from: ${{ env.STAGING_BASE_PATH }}/fragments"
          echo "Output file: ${{ env.RELEASES_PATH }}/targets.json"

          # Check for existing targets.json in the staging directory (persistent across builds)
          STAGING_PERSISTENT_DIR="$(dirname ${{ env.STAGING_BASE_PATH }})/${{ env.DISTRO_CODENAME }}"
          EXISTING_TARGETS_FILE="$STAGING_PERSISTENT_DIR/targets.json"

          if [ -f "$EXISTING_TARGETS_FILE" ] && [ -s "$EXISTING_TARGETS_FILE" ]; then
            echo "Found existing targets.json: $EXISTING_TARGETS_FILE"
            echo "Will merge with existing targets to preserve all available targets"
            ./repo/aggregate-targets.sh "${{ env.STAGING_BASE_PATH }}/fragments" "${{ env.RELEASES_PATH }}/targets.json" "$EXISTING_TARGETS_FILE"
          else
            echo "No existing targets.json found, creating new file"
            ./repo/aggregate-targets.sh "${{ env.STAGING_BASE_PATH }}/fragments" "${{ env.RELEASES_PATH }}/targets.json"
          fi

          # Update the persistent targets.json in staging directory for future builds
          echo "Updating persistent targets.json in staging directory"
          mkdir -p "$STAGING_PERSISTENT_DIR"
          cp "${{ env.RELEASES_PATH }}/targets.json" "$EXISTING_TARGETS_FILE"

          echo "targets.json generation complete"
