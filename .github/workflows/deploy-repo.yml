name: Deploy Repository

on:
  workflow_call:
    inputs:
      distro_codename:
        description: "Distribution codename"
        type: string
        required: true
      release_date:
        description: "Release date timestamp"
        type: string
        required: true
      packages_path:
        description: "Path to packages directory"
        type: string
        required: false
      releases_path:
        description: "Path to releases directory"
        type: string
        required: false

  workflow_dispatch:
    inputs:
      distro_codename:
        description: "Distribution codename"
        type: string
        default: "latest/apollo/edge"
      release_date:
        description: "Release date timestamp (leave empty for auto-generated)"
        type: string
        required: false
      packages_path:
        description: "Path to packages directory (leave empty for auto-generated)"
        type: string
        required: false
      releases_path:
        description: "Path to releases directory (leave empty for auto-generated)"
        type: string
        required: false


jobs:
  setup-paths:
    runs-on: avocado-sdk
    if: github.event_name == 'workflow_dispatch'
    outputs:
      release_date: ${{ steps.set-paths.outputs.release_date }}
      packages_path: ${{ steps.set-paths.outputs.packages_path }}
      releases_path: ${{ steps.set-paths.outputs.releases_path }}
    steps:
      - name: Set paths for manual dispatch
        id: set-paths
        run: |
          DISTRO_CODENAME="${{ inputs.distro_codename || github.event.inputs.distro_codename }}"
          REPO_PATH="/home/runner/_repo"

          # Handle release_date from inputs or find latest existing
          if [ -n "${{ inputs.release_date }}" ]; then
            RELEASE_DATE="${{ inputs.release_date }}"
            echo "Using provided release date: $RELEASE_DATE"
          elif [ -n "${{ github.event.inputs.release_date }}" ]; then
            RELEASE_DATE="${{ github.event.inputs.release_date }}"
            echo "Using input release date: $RELEASE_DATE"
          else
            # Try to find the latest existing release
            RELEASES_BASE="${REPO_PATH}/releases/${DISTRO_CODENAME}"
            if [ -d "$RELEASES_BASE" ]; then
              LATEST_DIR=$(find "$RELEASES_BASE" -maxdepth 1 -type d -not -path "$RELEASES_BASE" -printf '%T@ %p\n' 2>/dev/null | sort -nr | head -1 | cut -d' ' -f2-)
              if [ -n "$LATEST_DIR" ] && [ -d "$LATEST_DIR" ]; then
                RELEASE_DATE=$(basename "$LATEST_DIR")
                echo "Found latest existing release: $RELEASE_DATE"
              else
                RELEASE_DATE=$(date -u '+%Y-%m-%d-%H%M%S')
                echo "No existing releases found, generating new timestamp: $RELEASE_DATE"
              fi
            else
              RELEASE_DATE=$(date -u '+%Y-%m-%d-%H%M%S')
              echo "Releases directory doesn't exist, generating new timestamp: $RELEASE_DATE"
            fi
          fi

          # Handle packages_path from inputs or generate
          if [ -n "${{ inputs.packages_path }}" ]; then
            PACKAGES_PATH="${{ inputs.packages_path }}"
          elif [ -n "${{ github.event.inputs.packages_path }}" ]; then
            PACKAGES_PATH="${{ github.event.inputs.packages_path }}"
          else
            PACKAGES_PATH="${REPO_PATH}/packages/${DISTRO_CODENAME}"
          fi

          # Handle releases_path from inputs or generate
          if [ -n "${{ inputs.releases_path }}" ]; then
            RELEASES_PATH="${{ inputs.releases_path }}"
          elif [ -n "${{ github.event.inputs.releases_path }}" ]; then
            RELEASES_PATH="${{ github.event.inputs.releases_path }}"
          else
            RELEASES_PATH="${REPO_PATH}/releases/${DISTRO_CODENAME}/${RELEASE_DATE}"
          fi

          echo "Final paths:"
          echo "  Release date: $RELEASE_DATE"
          echo "  Packages path: $PACKAGES_PATH"
          echo "  Releases path: $RELEASES_PATH"

          echo "release_date=$RELEASE_DATE" >> $GITHUB_OUTPUT
          echo "packages_path=$PACKAGES_PATH" >> $GITHUB_OUTPUT
          echo "releases_path=$RELEASES_PATH" >> $GITHUB_OUTPUT

  cleanup_packages:
    needs: setup-paths
    if: always() && !cancelled()
    runs-on: avocado-sdk
    env:
      PACKAGES_PATH: ${{ inputs.packages_path || needs.setup-paths.outputs.packages_path }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Run cleanup script on packages directory
        run: |
          echo "Running cleanup script on ${{ env.PACKAGES_PATH }}"
          ./repo/purge-window.sh "${{ env.PACKAGES_PATH }}"

  sync_to_s3:
    needs: [setup-paths, cleanup_packages]
    if: always() && !cancelled()
    runs-on: avocado-build
    env:
      PACKAGES_PATH: ${{ inputs.packages_path || needs.setup-paths.outputs.packages_path }}
      RELEASES_PATH: ${{ inputs.releases_path || needs.setup-paths.outputs.releases_path }}
      DISTRO_CODENAME: ${{ inputs.distro_codename || github.event.inputs.distro_codename }}
      RELEASE_DATE: ${{ inputs.release_date || needs.setup-paths.outputs.release_date }}
      S3_BUCKET_PATH: ${{ secrets.AWS_S3_BUCKET }}
    steps:
      - name: Install rclone
        run: |
          curl https://rclone.org/install.sh | sudo bash

      - name: Configure rclone
        run: |
          mkdir -p ~/.config/rclone
          cat > ~/.config/rclone/rclone.conf << EOF
          [s3]
          type = s3
          provider = AWS
          access_key_id = ${{ secrets.AWS_ACCESS_KEY_ID }}
          secret_access_key = ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          region = ${{ secrets.AWS_REGION }}
          EOF

      - name: Sync packages directory to S3
        run: |
          echo "Syncing packages from ${{ env.PACKAGES_PATH }} to s3://${{ env.S3_BUCKET_PATH }}/packages/${{ env.DISTRO_CODENAME }}"
          rclone sync "${{ env.PACKAGES_PATH }}" "s3:${{ env.S3_BUCKET_PATH }}/packages/${{ env.DISTRO_CODENAME }}" --checksum --stats 5s --transfers 32

      - name: Sync release metadata to S3
        run: |
          echo "Syncing release metadata from ${{ env.RELEASES_PATH }} to s3://${{ env.S3_BUCKET_PATH }}/releases/${{ env.DISTRO_CODENAME }}/${{ env.RELEASE_DATE }}"
          rclone sync "${{ env.RELEASES_PATH }}" "s3:${{ env.S3_BUCKET_PATH }}/releases/${{ env.DISTRO_CODENAME }}/${{ env.RELEASE_DATE }}" --checksum --stats 5s --transfers 32
          echo "Release metadata S3 sync complete."

      - name: Sync metadata to S3
        run: |
          # First sync everything EXCEPT repomd.xml files. Then sync ONLY repomd.xml files. This
          # ensures that if a new repomd.xml is served, that the content it addresses exists.
          rclone sync "${{ env.RELEASES_PATH }}" "s3:${{ env.S3_BUCKET_PATH }}/${{ env.DISTRO_CODENAME }}" --checksum --exclude "*/repomd.xml" --stats 5s --transfers 32
          rclone sync "${{ env.RELEASES_PATH }}" "s3:${{ env.S3_BUCKET_PATH }}/${{ env.DISTRO_CODENAME }}" --checksum --include "*/repomd.xml" --exclude "*" --stats 5s --transfers 32

      - name: Clean up staging and releases directories
        run: |
          echo "Cleaning up staging and releases directories"

          # Clean up staging directory (derived from releases path)
          STAGING_BASE_PATH=$(dirname $(dirname "${{ env.RELEASES_PATH }}"))"/staging/${{ env.RELEASE_DATE }}"
          echo "Cleaning up staging directory: $STAGING_BASE_PATH"
          if [ -d "$STAGING_BASE_PATH" ]; then
            rm -rf "$STAGING_BASE_PATH"
            echo "Staging directory cleaned up successfully."
          fi

          echo "Cleanup completed"
